//
// Created by csfwang on 1/6/20.
//

#include "paramedeterm.h"
#include "InputParameter.h"
#include "math.h"
using namespace std;


Paramedeterm::Paramedeterm () {
    // TODO Auto-generated constructor stub
    numtotalxb=INT32_MAX;
    numdataxb=0;
    numgatherxb=0;
    dimcompressvector = 0;
}

Paramedeterm::~Paramedeterm() {
    // TODO Auto-generated destructor stub
}

//initialize parameters
void Paramedeterm::init(InputParameter inputParameter) {
    cout << endl << "==================================" << endl << "PARAMETER DETERMINE START" << endl << "==================================" << endl;
    //bit size of one crossbar
   int crossbarsize = inputParameter.xbColumnSize * inputParameter.xbRowSize * inputParameter.cellResolution;
   long long totalreramsize = inputParameter.reramtotalsize * 1024.0 * 1024.0 * 8.0 ;

   if(totalreramsize%crossbarsize==0){
       numtotalxb = totalreramsize/crossbarsize;
       printf("Crossbar total number: %d\n",  numtotalxb);
   }else{
       cout << "Please recheck ReRAM total size configure: modify it compatible with crossbar size" << endl;
   }
}

int Paramedeterm::determineparaforpim(InputParameter inputParameter) {

    dimcompressvector = inputParameter.vecDimension;\
    //calculate compress dimension s
    double reramtotalsizeinBit = inputParameter.reramtotalsize * 1024.0 * 1024.0 * 8.0;
    int onevectortakedataxb=0;
    int temonevectorcost=0;
    int cyclecount;
    int s = 1;
    unsigned long costsize = 0;
    for(s; s < inputParameter.vecDimension; s++){
        if(s < inputParameter.xbRowSize){
            //only data crossbar
            costsize = long (inputParameter.dataoriginalvolume) * long (inputParameter.intgerscalarlength) * s;
            numdataxb = ceil( inputParameter.dataoriginalvolume*inputParameter.intgerscalarlength*1
                              / double (inputParameter.xbRowSize * inputParameter.cellResolution) );
            if(costsize > reramtotalsizeinBit)
                break;
        }else{
            //need gather crossbar
            if( s <= inputParameter.xbRowSize * inputParameter.xbRowSize ){
                cyclecount = 2;
            }else{
                cout << "The vector length is too large, please calculate cyclecount precisely" << endl;
                double tem = 1.0/(inputParameter.xbRowSize);
                printf("%lf \n",pow(dimcompressvector,tem));
                cyclecount = ceil(pow(dimcompressvector,tem));
            }
            //here, we only consider compressed dimension smaller than 65536
            if(cyclecount == 2) {
                unsigned long totalxbnum = reramtotalsizeinBit/(inputParameter.xbRowSize * inputParameter.xbColumnSize * inputParameter.cellResolution);
                onevectortakedataxb = ceil(double(s)/inputParameter.xbRowSize);
                numdataxb = ceil( inputParameter.dataoriginalvolume*inputParameter.intgerscalarlength*onevectortakedataxb
                        / double (inputParameter.xbRowSize * inputParameter.cellResolution) );
                temonevectorcost = ceil( double(s) / (inputParameter.xbRowSize*inputParameter.xbRowSize )) ;
                numgatherxb = ceil( double(inputParameter.dataoriginalvolume*inputParameter.intgerscalarlength*temonevectorcost)
                        /(inputParameter.xbRowSize*inputParameter.cellResolution)) ;
                if( (numdataxb + numgatherxb) > totalxbnum)
                    break;
            }
        }
    }
    if(cyclecount == 2){
        cout << "PIM one vector cost data crossbar: " << onevectortakedataxb <<endl;
        cout << "PIM one vector cost gather crossbar: " << temonevectorcost << endl;
        cout << "PIM dataset cost data/gather crossbar:" << " " << numdataxb << "/" << numgatherxb << endl;
    }else{
        cout << "PIM one vector cost data crossbar: " << 1<<endl;
        cout << "PIM dataset cost data:" << " " << numdataxb << endl;
    }
}