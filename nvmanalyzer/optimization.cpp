//
// Created by wangf on 2/21/2020.
//

#include "optimization.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

bdoptimization::bdoptimization() {
    // TODO Auto-generated constructor stub
    //number of original bounds
    bdcandidatenum = 1;
    pimbdprunratio = 1;
    pimbddatacost = 0;
}

void bdoptimization::bdoptiminit(int origbdnum) {
    cout << endl << "==================================" << endl << "OPTIMIZATION START" << endl << "==================================" << endl;
    bdcandidatenum = origbdnum + 1;
    //init array:
    //0 - (bdcandidatenum-1) is original bound
    //bdcandidatenum is PIM bound
    pruneratio = new double[bdcandidatenum];
    datacost = new double[bdcandidatenum];
}

bdoptimization::~bdoptimization() {
    // TODO Auto-generated destructor stub
}


void bdoptimization::bdinforead(const std::string & inputFile) {
    FILE *fp = fopen(inputFile.c_str(), "r");
    char line[5000];
    char tmp[5000];
    if (!fp) {
        cout << inputFile << " cannot be found!\n";
        exit(-1);
    }
    while (fscanf(fp, "%[^\n]\n", line) != EOF) {
        //bound information
        if (!strncmp("-BoundA_Prunratio", line, strlen("-BoundA_Prunratio"))) {
            sscanf(line, "-BoundA_Prunratio: %lf", &pruneratio[0]);
            continue;
        }
        if (!strncmp("-BoundB_Prunratio", line, strlen("-BoundB_Prunratio"))) {
            sscanf(line, "-BoundB_Prunratio: %lf", &pruneratio[1]);
            continue;
        }
        if (!strncmp("-BoundC_Prunratio", line, strlen("-BoundC_Prunratio"))) {
            sscanf(line, "-BoundC_Prunratio: %lf", &pruneratio[2]);
            continue;
        }
        if (!strncmp("-BoundA_Datacost", line, strlen("-BoundA_Datacost"))) {
            sscanf(line, "-BoundA_Datacost: %lf", &datacost[0]);
            continue;
        }
        if (!strncmp("-BoundB_Datacost", line, strlen("-BoundB_Datacost"))) {
            sscanf(line, "-BoundB_Datacost: %lf", &datacost[1]);
            continue;
        }
        if (!strncmp("-BoundC_Datacost", line, strlen("-BoundC_Datacost"))) {
            sscanf(line, "-BoundC_Datacost: %lf", &datacost[2]);
            continue;
        }
    }
    cout << "Originalbound prunratio:" << pruneratio[0] <<" "<< pruneratio[1] <<" "<< pruneratio[2] <<" (%)"<< endl;
    cout << "Originalbound datacost:" << datacost[0] <<" "<< datacost[1] <<" "<< datacost[2] <<" (Byte)"<< endl;
    fclose(fp);
}




void bdoptimization::combine(int i, int j,vector<int> &r,int num,vector<vector<int> > & result){
    if (j == 1)
    {
        for (int k = 0; k < i; k++)
        {
            vector<int> temp(num);
            r[num - 1] = k;
            for (int i = 0; i < num;i++)
            {
                temp[i]=r[i];
                //cout << r[i] << ' ';
            }
            result.push_back(temp);
            //cout << endl;
        }
    }
    else if (j == 0)
    {
        //do nothing!
    }
    else
    {
        for (int k = i; k >= j; k--)
        {
            r[j-2] = k-1;
            combine(k - 1, j - 1,r,num,result);
        }
    }
}

void bdoptimization::boundrecommend(int datasetvolume) {
    //require pim bound prune ratio/data cost
    pimbdprunratio = 99.1;
    pimbddatacost = 24;
    pruneratio[bdcandidatenum -1] = pimbdprunratio;
    datacost[bdcandidatenum -1] = pimbddatacost;

    cout << "Bound candidate set have:" << bdcandidatenum << " bounds"<< endl;
    cout << "0 - " << bdcandidatenum - 2 << " is original bounds; ";
    cout << bdcandidatenum-1 << " is PIM-aware bound"<< endl;
    cout << "BoundNo  :   0      1     2     3"<<endl;
    cout << "Prunratio: " << pruneratio[0] <<" "<< pruneratio[1] <<" "<< pruneratio[2] <<" "<< pruneratio[3] <<" (%)"<< endl;
    cout << "Datacost : " << datacost[0] <<" "<< datacost[1] <<" "<< datacost[2] <<" "<< datacost[3]<<" (Byte)"<< endl;
    cout << "Calculating..." << endl;

    double totalcost = 0;
    double mimcost = DBL_MAX;
    vector<vector<int> > finalchooseinorder;
    int flag = 0;
    int mark = 0;
   //choose 1 to bdcandidatenum bounds for bound candidate set
    for(int i = 1; i <= bdcandidatenum; i++){
        vector<int> choosearraytemp(i);
        vector<vector<int> > choosearray;
        combine(bdcandidatenum,i,choosearraytemp,i,choosearray);
        int arraysize = choosearray.size();
        for(int j = 0;j < arraysize;j++ ){
            int *permutaarray = new int[i];
            for (int k = 0; k < i; k++){
                permutaarray[k] = choosearray[j][k];
                //cout << choosearray[j][k];
            }
            //cout <<"---------choose bound num:"<< i << endl;
            std::sort (permutaarray,permutaarray+i);
            do
            {
                int volumeafterprune = datasetvolume;
                vector<int> temp(i);
                for(int z=0; z<i; z++) {
                    temp[z] = permutaarray[z];
                    int currentbd = permutaarray[z];
                    totalcost += volumeafterprune * datacost[currentbd];
                    volumeafterprune = volumeafterprune * ( 1 - pruneratio[currentbd]/100.0);
                    //cout << permutaarray[z] << " ";
                    //cout<< " unpru:" << volumeafterprune << "||";
                }
                finalchooseinorder.push_back(temp);
                if(totalcost < mimcost){
                    mimcost = totalcost;
                    flag = mark;
                }
                //cout<< " Final " << totalcost<< endl;
                totalcost = 0;
                mark ++;
            }while(next_permutation(permutaarray,permutaarray+i));
        }
    }

    cout<< "Recommend bound choose(in order): ";
    for(int k = 0; k < finalchooseinorder[flag].size(); k++){
        cout<< finalchooseinorder[flag][k];
    }
    cout<<endl << "Least datacost: " << mimcost/1024<< "(MB)" <<endl;
}



